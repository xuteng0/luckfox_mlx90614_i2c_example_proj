[b]I2C Communication on Linux: A Hands-On Tutorial with MLX90614[/b]

[size=150]Table of Contents[/size]

[list]
[*]1. Setup
[list]
[*]1.1 MLX90614 Sensor Introduction
[*]1.2 Hardware Connections
[*]1.3 Enable I2C Bus in Device Tree
[*]1.4 Enable i2c-tools
[*]1.5 Choose Your Implementation Approach
[/list]
[*]2. Read Sensor Data via Generic I2C Interface
[list]
[*]2.1 Use i2c-tools to Read Registers
[*]2.2 Shell Script to Print Sensor Data
[*]2.3 C Program to Log Data
[/list]
[*]3. Read Sensor Data using Kernel Driver
[list]
[*]3.1 Enable Driver in SDK using Kernel Config Tool
[*]3.2 Specify Driver in Device Tree
[*]3.3 Shell Commands to Log Sensor Data via Kernel Driver
[*]3.4 C Program to Log Sensor Data via Kernel Driver
[/list]
[*]4. Conclusion
[/list]

[size=150]1.1 MLX90614 Sensor Introduction[/size]

The MLX90614 is a simple I2C non-contact temperature sensor.

[b]I2C Address:[/b] 0x5A

[b]Registers of Interest:[/b]
[list]
[*][b]0x06[/b] - Ambient Temperature (Ta)
[*][b]0x07[/b] - Object Temperature (To)
[*][b]0x0E[/b] - Sensor ID
[/list]

Each register contains 16 bits (2 bytes) of data.

[b]Temperature Conversion:[/b]
[code]Temperature (°C) = (raw_value × 0.02) - 273.15[/code]

[i]For detailed conversion formulas and accuracy specifications, see the [url=https://www.melexis.com/-/media/files/documents/datasheets/mlx90614-datasheet-melexis.pdf]MLX90614 Datasheet[/url].[/i]

[b]Product Page:[/b] [url=https://www.waveshare.com/wiki/Infrared_Temperature_Sensor]Waveshare Infrared Temperature Sensor[/url]

[size=150]1.2 Hardware Connections[/size]

Choose I2C connectors from: [url=https://wiki.luckfox.com/Luckfox-Pico/Luckfox-Pico-RV1106/Luckfox-Pico-Ultra-W/Luckfox-Pico-I2C]Luckfox Pico I2C Documentation[/url]

[b]Our Choice: I2C2 M0[/b]
[list]
[*]SDA: Pin 3 (GPIO1_C7)
[*]SCL: Pin 5 (GPIO1_D0)
[*]VCC: 3.3V
[*]GND: Ground
[/list]

Connect the MLX90614 sensor to these pins.

[size=150]1.3 Enable I2C Bus in Device Tree[/size]

Edit the device tree to enable I2C2. We choose I2C2 M0 since only M0 is exposed on the dev board.

[b]Note:[/b] [i]config/dts_config[/i] is a symlink and should be ignored by git. To find the actual file to edit, use:
[code]$ file config/dts_config # Example output: 
config/dts_config: symbolic link to ../sysdrv/source/kernel/arch/arm64/boot/dts/rockchip/rv1106g-luckfox-pico-ultra-w.dts[/code]

Add the following DTS settings at the end of the actual dts file:

[code]/**********I2C2**********/
&i2c2 {
	status = "okay";
	clock-frequency = <100000>;
};[/code]

[i]Note: For quick testing, you can also temporarily enable I2C2 using [i]luckfox-config[/i] on the board via SSH as described in the [url=https://wiki.luckfox.com/Luckfox-Pico/Luckfox-Pico-RV1106/Luckfox-Pico-Ultra-W/Luckfox-config]Luckfox-config documentation[/url].[/i]

[size=150]1.4 Enable i2c-tools[/size]

This installs [i]i2cget[/i], [i]i2cset[/i], [i]i2cdetect[/i], and other I2C utilities on the target system.

[b]Enable i2c-tools in Buildroot[/b]

[b]Start Docker Container[/b]
[i]Note: If you haven't set up the Docker environment yet, follow the [url=https://wiki.luckfox.com/Luckfox-Pico/Luckfox-Pico-RV1106/Luckfox-Pico-Ultra-W/Luckfox-Pico-SDK#2-docker-environment]Luckfox Pico SDK Docker setup guide[/url] first.[/i]
[code]$ sudo docker start -ai luckfox
root@container:/# 

# Navigate to build directory
root@container:/home# cd /home/
root@container:/home# [/code]

There are two ways to enable i2c-tools:

[b]Method 1: GUI Configuration (Recommended)[/b]
Run the following command to open a GUI window (ensure your terminal window has enough height):
[code]root@container:/home# ./build.sh buildrootconfig[/code]
Navigate to: [i]Target packages[/i] → [i]Hardware handling[/i] → [i]i2c-tools[/i]
Enable [i]i2c-tools[/i] package
Save and exit

[b]Method 2: Direct File Edit[/b]
Alternatively, you can directly edit the buildroot configuration file:
[code]root@container:/home# echo "BR2_PACKAGE_I2C_TOOLS=y" >> config/buildroot_defconfig[/code]

Both methods add a [i]BR2_PACKAGE_I2C_TOOLS=y[/i] line in the buildroot config file. You can verify with:
[code]$ grep I2C_TOOLS config/buildroot_defconfig
BR2_PACKAGE_I2C_TOOLS=y[/code]

[b]Rebuild and Flash[/b]

[b]Inside Docker container:[/b]
[code]root@container:/home# ./build.sh all[/code]

[b]Outside Docker container (with sudo):[/b]
[code]$ sudo ./build.sh flash[/code]

[b]SSH to Luckfox Board[/b]
[code]ssh root@<board-ip>[/code]

[b]Verify I2C Bus[/b]
[code]root@luckfox:~# ls /dev/i2c*
/dev/i2c-2  /dev/i2c-3  /dev/i2c-4[/code]

We should see [i]/dev/i2c-2[/i] which corresponds to the I2C2 bus we enabled in the device tree. If we remove the I2C2 configuration from the DTS and rebuild/flash again, [i]/dev/i2c-2[/i] will disappear.

[b]Verify Sensor Detection[/b]
[code]root@luckfox:~# i2cdetect -y 2[/code]

Expected output:
[code]     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:                         -- -- -- -- -- -- -- -- 
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
50: -- -- -- -- -- -- -- -- -- -- 5a -- -- -- -- -- 
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
70: -- -- -- -- -- -- -- --   [/code]

The [i]5a[/i] at address 0x5a indicates the MLX90614 sensor is detected and responding on I2C bus 2.

[b]If you see [i]UU[/i] instead of [i]5a[/i]:[/b]
This means the sensor is being used by a kernel driver. To use i2c-tools, you need to unload the driver first:
[code]root@luckfox:~# rmmod mlx90614[/code]
Then run [i]i2cdetect -y 2[/i] again to see the [i]5a[/i] address.

[size=150]1.5 Choose Your Implementation Approach[/size]

This tutorial covers two different methods for reading data from the MLX90614 temperature sensor on the Luckfox Pico:

[b]Method 1: Generic I2C Interface (Sections 2.x)[/b]
[list]
[*][b]Best for:[/b] Learning I2C fundamentals, debugging, custom implementations
[*][b]Pros:[/b] Direct control, no kernel dependencies, works with any I2C device
[*][b]Cons:[/b] Manual data conversion, more complex error handling
[*][b]Tools:[/b] i2c-tools, custom C programs using Linux I2C API
[/list]

[b]Method 2: Kernel Driver with IIO Interface (Sections 3.x)[/b]
[list]
[*][b]Best for:[/b] Production applications, standardized sensor interfaces
[*][b]Pros:[/b] Automatic data conversion, standardized interface, better error handling
[*][b]Cons:[/b] Requires kernel configuration, more complex setup
[*][b]Tools:[/b] IIO device files, kernel driver modules
[/list]

[b]Recommendation:[/b] Start with Method 1 to understand I2C basics, then use Method 2 for production applications.

[size=150]2.1 Use i2c-tools to Read Registers[/size]

Now that we have i2c-tools installed and can detect our MLX90614 sensor, let's use the tools to read the sensor's registers and extract temperature data.

[b]Reading Multiple Registers at Once[/b]

You can use [i]i2cdump[/i] to read a range of registers and get an overview of all sensor data:

[code]root@luckfox:~# i2cdump -y 2 0x5a w
     0,8  1,9  2,a  3,b  4,c  5,d  6,e  7,f
00: 2629 0098 XXXX 1a15 XXXX 0008 39b3 3998 
08: 3bc4 0000 0008 XXXX 04b1 0000 3998 XXXX 
10: 8067 1b58 040d 0007 XXXX 0002 XXXX 0000 
18: 01ff 801c 04a9 XXXX 0012 0162 XXXX 01ba 
20: 9993 62e3 0201 f71c ffff aff4 6b11 6bb5 
28: 6ef6 XXXX 95f5 1100 XXXX 20b9 XXXX 079a 
30: 9e69 75d3 53e3 8021 8020 1d2b 00c1 XXXX 
38: 0013 0000 XXXX 8011 e806 e560 1123 e1d0 
40: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
48: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
50: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
58: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
60: XXXX XXXX 44b7 XXXX XXXX 44b8 XXXX 0000 
68: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
70: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
78: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
80: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
88: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
90: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
98: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
a0: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
a8: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
b0: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
b8: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
c0: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
c8: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
d0: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
d8: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
e0: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
e8: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX 
f0: f701 40e6 40da 0024 40dd 40e2 40df 0000 
f8: 40d9 2d14 XXXX d790 XXXX 40d9 XXXX XXXX [/code]

This shows all registers in a readable format. You can see:
[list]
[*]Register 0x06: [i]39b3[/i] (ambient temperature)
[*]Register 0x07: [i]3998[/i] (object temperature)  
[*]Register 0x0E: [i]2629[/i] (sensor ID)
[/list]

The [i]XXXX[/i] entries indicate registers that are either not readable or contain invalid data.

[b]Reading Individual Registers[/b]

The [i]i2cget[/i] command allows us to read specific registers from the sensor. Since the MLX90614 uses 16-bit registers, we need to read 2 bytes at a time.

[code]# Read the three main registers from MLX90614 sensor
root@luckfox:~# i2cget -y 2 0x5a 0x06 w  # Ambient Temperature register
0x39c2                      # Raw value: 14786 decimal → 22.42°C

root@luckfox:~# i2cget -y 2 0x5a 0x07 w  # Object Temperature register  
0x39cb                      # Raw value: 14795 decimal → 22.64°C

root@luckfox:~# i2cget -y 2 0x5a 0x0e w  # Sensor ID register
0x3c65                      # Raw value: 15461 decimal → Sensor ID[/code]

The [i]w[/i] flag tells i2cget to read a 16-bit word (2 bytes) in little-endian format, which is what the MLX90614 uses.

[b]Note:[/b] Raw register values need to be converted to actual temperatures using the formula:
[code]Temperature (°C) = (raw_value × 0.02) - 273.15[/code]

[size=150]2.2 Shell Script to Print Sensor Data[/size]

Using [i]i2cget[/i], we can use the script to log sensor data. For simplicity, we create [i]read_mlx90614.sh[/i] directly in the luckfox [i]/root/[/i] directory:

[code]#!/bin/bash

I2C_BUS="2"
SENSOR_ADDR="0x5a"
TEMP_AMBIENT_REG="0x06"
TEMP_OBJECT_REG="0x07"

# Check if i2c-tools is installed
if ! command -v i2cget &> /dev/null; then
    echo "Error: i2c-tools not found. Install with: opkg install i2c-tools"
    exit 1
fi

# Check if I2C device exists
if [ ! -e "/dev/i2c-$I2C_BUS" ]; then
    echo "Error: I2C bus /dev/i2c-$I2C_BUS not found"
    exit 1
fi

echo "MLX90614 Temperature Reader (Ctrl+C to exit)"
echo "============================================="

while true; do
    # Read ambient temperature
    ambient_raw=$(i2cget -y $I2C_BUS $SENSOR_ADDR $TEMP_AMBIENT_REG w 2>/dev/null)
    if [ $? -eq 0 ]; then
        ambient_c=$(echo "scale=1; ($(printf "%d" $ambient_raw) * 0.02) - 273.15" | bc -l)
        echo "Ambient: ${ambient_c}°C"
    fi
    
    # Read object temperature
    object_raw=$(i2cget -y $I2C_BUS $SENSOR_ADDR $TEMP_OBJECT_REG w 2>/dev/null)
    if [ $? -eq 0 ]; then
        object_c=$(echo "scale=1; ($(printf "%d" $object_raw) * 0.02) - 273.15" | bc -l)
        echo "Object:  ${object_c}°C"
    fi
    
    echo "---"
    sleep 2
done[/code]

[b]Sample output from running the script:[/b]
[code]root@luckfox:~# ./read_mlx90614.sh
MLX90614 Temperature Reader (Ctrl+C to exit)
=============================================
Ambient: 22.33°C
Object:  22.17°C
---
Ambient: 22.31°C
Object:  22.07°C
---
Ambient: 22.35°C
Object:  21.95°C
---
...[/code]

The script continuously monitors both ambient and object temperatures, updating every 2 seconds. Press Ctrl+C to exit.

[b]Note:[/b] This script uses [i]bc[/i] for floating-point calculations. In this Buildroot configuration, [i]bc[/i] is provided by busybox, if you are using [i]systemd[/i] you can enable bc in buildroot config:

[code]# Inside Docker container
root@container:/home# ./build.sh buildrootconfig[/code]
Navigate to: [i]Target packages[/i] → [i]Miscellaneous[/i] → [i]bc[/i]
Enable the [i]bc[/i] package and save the configuration.

[size=150]2.3 C Program to Log Data[/size]

While shell scripts are convenient for quick testing, C programs offer better performance and more control over I2C communication. Let's create a C program that directly interfaces with the I2C bus.

[b]The C Program[/b]

[b]Project Structure:[/b]
[code]project/app/read_MLX90614/
├── read_mlx90614.c      # C program source code
├── read_mlx90614.sh     # Shell script version
├── Makefile             # Build configuration
└── i2c_read_tutorial.md # This tutorial[/code]
[i]Note:[/i] We've put the .sh file in the project as well for convenience

Create [i]read_mlx90614.c[/i]:

[code]#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/i2c-dev.h>
#include <linux/i2c.h>
#include <errno.h>
#include <string.h>
#include <byteswap.h>

#define I2C_BUS 2
#define SENSOR_ADDR 0x5a
#define TEMP_AMBIENT_REG 0x06
#define TEMP_OBJECT_REG 0x07

int i2c_fd = -1;

// Function to read 16-bit register from I2C device using SMBus protocol
int read_register(int reg) {
    struct i2c_smbus_ioctl_data args;
    union i2c_smbus_data data;
    
    args.read_write = I2C_SMBUS_READ;
    args.command = reg;
    args.size = I2C_SMBUS_WORD_DATA;
    args.data = &data;
    
    if (ioctl(i2c_fd, I2C_SMBUS, &args) < 0) {
        return -1;
    }
    
    // MLX90614 returns data in big-endian format, but i2c_smbus_read_word_data
    // already handles the byte swapping, so we return the value as-is
    return data.word;
}

// Function to convert raw temperature to Celsius
float raw_to_celsius(int raw_value) {
    return (raw_value * 0.02) - 273.15;
}

int main() {
    char i2c_device[20];
    int ambient_raw, object_raw;
    float ambient_c, object_c;
    
    // Check if I2C device exists
    snprintf(i2c_device, sizeof(i2c_device), "/dev/i2c-%d", I2C_BUS);
    if (access(i2c_device, F_OK) != 0) {
        printf("Error: I2C bus %s not found\n", i2c_device);
        return 1;
    }
    
    // Open I2C device
    i2c_fd = open(i2c_device, O_RDWR);
    if (i2c_fd < 0) {
        printf("Error: Cannot open %s: %s\n", i2c_device, strerror(errno));
        return 1;
    }
    
    // Set slave address
    if (ioctl(i2c_fd, I2C_SLAVE, SENSOR_ADDR) < 0) {
        printf("Error: Cannot set slave address 0x%02x: %s\n", SENSOR_ADDR, strerror(errno));
        close(i2c_fd);
        return 1;
    }
    
    printf("MLX90614 Temperature Reader (Ctrl+C to exit)\n");
    printf("=============================================\n");
    
    while (1) {
        // Read ambient temperature
        ambient_raw = read_register(TEMP_AMBIENT_REG);
        if (ambient_raw >= 0) {
            ambient_c = raw_to_celsius(ambient_raw);
            printf("Ambient: %.1f°C\n", ambient_c);
        } else {
            printf("Ambient: Error reading sensor\n");
        }
        
        // Read object temperature
        object_raw = read_register(TEMP_OBJECT_REG);
        if (object_raw >= 0) {
            object_c = raw_to_celsius(object_raw);
            printf("Object:  %.1f°C\n", object_c);
        } else {
            printf("Object:  Error reading sensor\n");
        }
        
        printf("---\n");
        sleep(2);
    }
    
    close(i2c_fd);
    return 0;
}[/code]

Create Makefile

[code]# Include Luckfox SDK build parameters
ifeq ($(APP_PARAM), )
    APP_PARAM := ../Makefile.param
    include $(APP_PARAM)
endif

export LC_ALL := C
SHELL := /bin/bash

CURRENT_DIR := $(shell pwd)

# Project configuration
PKG_NAME := read_MLX90614
PKG_BIN  ?= out

# Compiler flags for cross-compilation
READ_MLX90614_CFLAGS  := $(RK_APP_OPTS) $(RK_APP_CROSS_CFLAGS)
READ_MLX90614_LDFLAGS := $(RK_APP_OPTS) $(RK_APP_LDFLAGS)

PKG_TARGET := read_MLX90614-build

# Main build target
all: $(PKG_TARGET)
	@echo "build $(PKG_NAME) done"

# Build the project: compile C program and copy shell script
read_MLX90614-build:
	@rm -rf $(PKG_BIN); \
	mkdir -p $(PKG_BIN)/bin
	# Compile the C program using cross-compiler
	$(RK_APP_CROSS)-gcc $(READ_MLX90614_CFLAGS) read_mlx90614.c -o $(PKG_BIN)/bin/read_MLX90614 $(READ_MLX90614_LDFLAGS)
	# Copy shell script and make it executable
	cp read_mlx90614.sh $(PKG_BIN)/bin/
	chmod +x $(PKG_BIN)/bin/read_mlx90614.sh
	# Copy built files to app output directory
	$(call MAROC_COPY_PKG_TO_APP_OUTPUT, $(RK_APP_OUTPUT), $(PKG_BIN))

# Clean build output
clean:
	@rm -rf $(PKG_BIN)

distclean: clean

# Show build information
info:
	@echo "This is $(PKG_NAME) for $(RK_APP_CHIP) with $(RK_APP_CROSS)"[/code]

[i]Note:[/i] The Makefile copies both the compiled C program ([i]read_MLX90614[/i]) and the shell script ([i]read_mlx90614.sh[/i]) to the output directory. This gives users the choice between running the high-performance C program or the simpler shell script version.

[b]Expected files after build and flash:[/b]
After building and flashing, you should find these files on the target system:

[code]# On the target board (via SSH)
root@luckfox:~# pwd
/oem/usr/bin
root@luckfox:~# ls read_*
read_mlx90614     read_mlx90614.sh[/code]

Both executables are now available system-wide and can be run from any directory.

[b]Sample output:[/b]
[code]# Run the shell script
root@luckfox:~# ./read_mlx90614.sh 
MLX90614 Temperature Reader (Ctrl+C to exit)
=============================================
Ambient: 23.21°C
Object:  23.05°C
---
Ambient: 23.19°C
Object:  23.11°C
---
^C

# Run the C program
root@luckfox:~# ./read_mlx90614
MLX90614 Temperature Reader (Ctrl+C to exit)
=============================================
Ambient: 23.2°C
Object:  22.8°C
---
Ambient: 23.2°C
Object:  23.1°C
---
^C[/code]

[size=150]3.1 Enable Driver in SDK using Kernel Config Tool[/size]

The MLX90614 kernel driver is already included in the Luckfox Buildroot SDK. The source code is located in the kernel source tree:

[code]# Driver source file
sysdrv/source/kernel/drivers/iio/temperature/mlx90614.c[/code]
This driver provides a standardized IIO (Industrial I/O) interface for reading sensor data.

[b]Why is the I2C sensor driver under IIO?[/b]

[i]IIO (Industrial I/O)[/i] is a Linux kernel framework designed specifically for sensors and data acquisition devices. IIO device drivers are purpose-built for sensors - they provide automatic data conversion (raw values to physical units), standardized sensor interfaces, and create consistent user-space files like [i]in_temp_ambient_raw[/i] for easy access. Whereas I2C device drivers are generic communication drivers that only handle raw data transfer and would require custom interfaces for each sensor type, making them too low-level for sensor applications.

[b]Kernel Configuration Options[/b]

There are 3 options for a Kernel Driver Configuration:
[list]
[*][i]n[/i] (No): Driver is not compiled
[*][i]m[/i] (Module): Driver is compiled as a loadable kernel module (recommended)
[*][i]y[/i] (Yes): Driver is compiled directly into the kernel (built-in)
[/list]

We will enable the driver as a module.

[b]Enable the MLX90614 Driver[/b]

[b]Configure Kernel:[/b]
Run the build process in the Luckfox Docker container:
[i](See the [url=https://wiki.luckfox.com/Luckfox-Pico-Ultra/Docker-Image-Build]official guide[/url] on setting up the Docker environment)[/i]

There are two ways to enable the MLX90614 driver:

[b]Method 1: GUI Configuration (Recommended)[/b]
In [i]/home/[/i] of the docker container, run the following command to open a GUI window (ensure your terminal window has enough height):
[code]root@container:/home# ./build.sh kernelconfig[/code]
Navigate to [i]Device Drivers[/i] → [i]Industrial I/O support[/i] → [i]Temperature sensors[/i] and set [i]MLX90614 contactless IR temperature sensor[/i] to [i]M[/i] (Module).

[b]Method 2: Direct File Edit[/b]
Alternatively, you can directly edit the kernel configuration file:
[code]root@container:/home# echo "CONFIG_MLX90614=m" >> config/kernel_defconfig[/code]

Both methods add a [i]CONFIG_MLX90614[/i] line in the kernel config file. You can verify with:
[code]root@container:/home# grep MLX90614 config/kernel_defconfig
CONFIG_MLX90614=m[/code]

[b]Build and Flash[/b]
Build the kernel and firmware, then flash to the board.

[b]Verify Driver Loading[/b]

[b]SSH to the board and check if the module file exists:[/b]
[code]root@luckfox:~# ls /oem/usr/ko/mlx*
ko/mlx90614.ko[/code]

[b]Load the MLX90614 module:[/b]
[code]root@luckfox:~# insmod /oem/usr/ko/mlx90614.ko[/code]

[i]Note: We use [i]insmod[/i] instead of [i]modprobe[/i] because the system uses busybox, which doesn't have the full modprobe functionality expected in standard Linux distributions.[/i]

[b]Check if driver is loaded:[/b]
[code]root@luckfox:~# lsmod | grep mlx90614
mlx90614                4331  0[/code]

[b]Check IIO device:[/b]
[code]root@luckfox:~# ls /sys/bus/iio/devices/
iio:device0[/code]

[i]Note: At this point, you won't see the MLX90614 IIO device yet because the device tree configuration hasn't been set up. The driver is loaded but doesn't know where to find the sensor. This will be resolved in the next section when we configure the device tree.[/i]

[size=150]3.2 Specify Driver in Device Tree[/size]

The MLX90614 device tree configuration is already included in the Luckfox SDK. The driver needs to know which I2C bus and address to use, which is specified in the device tree.

[b]Existing Device Tree Configuration[/b]

The Luckfox SDK already includes the MLX90614 device tree configuration in [i]rv1106g-luckfox-pico-ultra-w.dts[/i]:

[code]/**********I2C2**********/
&i2c2 {
	status = "okay";                    
	clock-frequency = <100000>;  

	// Add the section below
	mlx90614@5a {                           // Device node for MLX90614 sensor          
		compatible = "melexis,mlx90614";    //Matches the driver's compatible string
		reg = <0x5a>;                       //I2C address
	};                                      
};[/code]

The device tree tells the kernel exactly where to find the MLX90614 sensor, enabling automatic driver loading and IIO interface creation.

After build, flash, and SSH, verify the MLX90614 sensor is now detected:

[b]Load the MLX90614 module with [i]insmod[/i][/b]
[code]root@luckfox:~# insmod /oem/usr/ko/mlx90614.ko[/code]

[b]Check if driver is loaded with [i]lsmod[/i][/b]
[code]root@luckfox:~# lsmod | grep mlx90614
mlx90614                4331  0[/code]

[b]Verify IIO device creation:[/b]
[code]root@luckfox:~# ls /sys/bus/iio/devices/
iio:device0  iio:device1[/code]

[b]Verify sensor name:[/b]
[code]root@luckfox:~# cat /sys/bus/iio/devices/iio:device1/name
mlx90614[/code]
Now we have the MLX90614 sensor as IIO devices on [i]iio:device1[/i]

[b]Check sensor files:[/b]
[code]root@luckfox:~# ls /sys/bus/iio/devices/iio:device1/
in_temp_ambient_raw  in_temp_object_raw  name  power  subsystem  uevent
in_temp_offset       in_temp_scale[/code]

The presence of [i]in_temp_ambient_raw[/i], [i]in_temp_object_raw[/i], [i]in_temp_scale[/i], and [i]in_temp_offset[/i] files indicates the MLX90614 driver is working correctly and has detected the sensor.

[b]Read sensor values using kernel driver:[/b]
[code]# Read ambient temperature (raw value)
root@luckfox:~# cat /sys/bus/iio/devices/iio:device1/in_temp_ambient_raw
14811

# Read object temperature (raw value)
root@luckfox:~# cat /sys/bus/iio/devices/iio:device1/in_temp_object_raw
14821

# Read temperature scale factor
root@luckfox:~# cat /sys/bus/iio/devices/iio:device1/in_temp_scale
20

# Read temperature offset
root@luckfox:~# cat /sys/bus/iio/devices/iio:device1/in_temp_offset
-13657.500000[/code]

[b]Convert raw values to Celsius:[/b]

Formula: [i](raw + offset) * scale / 1000[/i]
[code]# Ambient temperature: (14811 + (-13657.5)) * 20 / 1000 = 22.7°C
root@luckfox:~# echo "scale=1; (($(cat /sys/bus/iio/devices/iio:device1/in_temp_ambient_raw) + $(cat /sys/bus/iio/devices/iio:device1/in_temp_offset)) * $(cat /sys/bus/iio/devices/iio:device1/in_temp_scale)) / 1000" | bc -l
22.7

# Object temperature: (14821 + (-13657.5)) * 20 / 1000 = 22.9°C
root@luckfox:~# echo "scale=1; (($(cat /sys/bus/iio/devices/iio:device1/in_temp_object_raw) + $(cat /sys/bus/iio/devices/iio:device1/in_temp_offset)) * $(cat /sys/bus/iio/devices/iio:device1/in_temp_scale)) / 1000" | bc -l
22.9[/code]

[b]Unloading the Driver with [i]rmmod[/i][/b]

When you're done testing with the kernel driver, you can unload it to free up the I2C bus for other applications:

[code]# Unload the MLX90614 kernel driver
root@luckfox:~# rmmod mlx90614

# Verify the driver is unloaded
root@luckfox:~# lsmod | grep mlx90614
# (no output means driver is unloaded)

# Check that I2C bus is now available for i2c-tools
root@luckfox:~# i2cdetect -y 2
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:                         -- -- -- -- -- -- -- -- 
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
50: -- -- -- -- -- -- -- -- -- -- 5a -- -- -- -- -- 
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
70: -- -- -- -- -- -- -- --   [/code]

Now you can use the generic I2C tools (i2cget, i2cset, etc.) to communicate directly with the sensor.

This confirms that [i]iio:device1[/i] is indeed the MLX90614 sensor and shows how to read temperature values using the kernel driver.

[size=150]3.3 Shell Commands to Log Sensor Data via Kernel Driver[/size]

Now that we have the MLX90614 kernel driver loaded and the IIO interface available, we can create a shell script that reads temperature data directly from the IIO device files.

[b]IIO Shell Script[/b]

Create [i]read_mlx90614_iio.sh[/i]:

[code]#!/bin/bash

# MLX90614 IIO Temperature Reader Script
# This script reads temperature data from MLX90614 sensor via IIO interface

# Configuration
IIO_DEVICE="/sys/bus/iio/devices/iio:device1"
OBJECT_RAW="$IIO_DEVICE/in_temp_object_raw"
AMBIENT_RAW="$IIO_DEVICE/in_temp_ambient_raw"
SCALE="$IIO_DEVICE/in_temp_scale"
OFFSET="$IIO_DEVICE/in_temp_offset"

# Function to read temperature from IIO
read_temperature() {
    local raw_file=$1
    local temp_name=$2
    
    if [ ! -f "$raw_file" ]; then
        echo "Error: $raw_file not found"
        return 1
    fi
    
    # Read raw value
    local raw_value=$(cat "$raw_file")
    
    # Read scale and offset
    local scale=$(cat "$SCALE")
    local offset=$(cat "$OFFSET")
    
    # Convert to temperature in Celsius
    # Formula: (raw_value + offset) * scale / 1000
    local temp_c=$(echo "scale=2; ($raw_value + $offset) * $scale / 1000" | bc -l)
    
    echo "$temp_name Temperature: ${temp_c}°C"
}

# Function to check if sensor is present
check_sensor() {
    if [ ! -d "$IIO_DEVICE" ]; then
        echo "✗ MLX90614 sensor not found at $IIO_DEVICE"
        echo "Make sure the module is loaded: modprobe mlx90614"
        return 1
    else
        echo "✓ MLX90614 sensor found at $IIO_DEVICE"
        return 0
    fi
}

# Main execution
echo "MLX90614 Temperature Reader (Ctrl+C to exit)"
echo "============================================="

# Check if sensor is present
if ! check_sensor; then
    exit 1
fi

echo ""

# Read temperatures
while true; do
    read_temperature "$OBJECT_RAW" "Object"    # Read object temperature
    read_temperature "$AMBIENT_RAW" "Ambient"  # Read ambient temperature 
    echo "---"
    sleep 2    # Wait 2 seconds before next reading
done[/code]

[b]How the IIO Script Works[/b]

[b]Key Differences from I2C Script:[/b]
[list]
[*][b]Uses IIO Interface:[/b] Reads from [i]/sys/bus/iio/devices/iio:device1/[/i] instead of raw I2C registers
[*][b]Automatic Conversion:[/b] Uses the driver-provided scale and offset values for accurate temperature conversion
[*][b]Error Handling:[/b] Checks for IIO device presence and file availability
[*][b]Standard Formula:[/b] Uses the IIO standard formula [i](raw + offset) * scale / 1000[/i]
[/list]

[b]Temperature Conversion:[/b]
The script uses the formula provided by the MLX90614 driver:
[code]Temperature (°C) = (raw_value + offset) * scale / 1000[/code]

Where:
[list]
[*][i]raw_value[/i]: Raw sensor reading from IIO device
[*][i]offset[/i]: -13657.5 (Kelvin offset from driver)
[*][i]scale[/i]: 20 (represents 0.02 Kelvin per raw unit)
[/list]

[b]Running the IIO Script[/b]

[b]Important:[/b] Before running the IIO script, you must load the MLX90614 kernel driver:

[code]# Load the MLX90614 kernel module
root@luckfox:~# insmod /oem/usr/ko/mlx90614.ko

# Verify the driver is loaded
root@luckfox:~# lsmod | grep mlx90614
mlx90614                4331  0

# Check that the IIO device is created
root@luckfox:~# ls /sys/bus/iio/devices/
iio:device0  iio:device1

# Verify the sensor name
root@luckfox:~# cat /sys/bus/iio/devices/iio:device1/name
mlx90614

# Now run the IIO script
root@luckfox:~# ./read_mlx90614_iio.sh
MLX90614 Temperature Reader (Ctrl+C to exit)
=============================================
✓ MLX90614 sensor found at /sys/bus/iio/devices/iio:device1

Object Temperature: 22.95°C
Ambient Temperature: 22.70°C
---
Object Temperature: 22.97°C
Ambient Temperature: 22.72°C
---
Object Temperature: 22.93°C
Ambient Temperature: 22.68°C
---
^C[/code]

[size=150]3.4 C Program to Log Sensor Data via Kernel Driver[/size]

While the IIO shell script is convenient for quick testing, a C program offers better performance and more control over sensor data reading. Let's create a C program that reads temperature data directly from the IIO device files.

[b]The IIO C Program[/b]

[b]Project Structure:[/b]
[code]project/app/read_MLX90614/
├── read_mlx90614.c          # I2C C program source code
├── read_mlx90614_iio.c      # IIO C program source code
├── read_mlx90614.sh         # I2C shell script version
├── read_mlx90614_iio.sh     # IIO shell script version
├── Makefile                 # Build configuration
└── i2c_read_tutorial.md     # This tutorial[/code]

[b]Why Dynamic Device Discovery?[/b]
The IIO device number (e.g., [i]iio:device1[/i]) can vary depending on system configuration and the order in which drivers are loaded. Using dynamic discovery makes your code more robust and portable.

Create [i]read_mlx90614_iio.c[/i] with dynamic device discovery:

[code]#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <math.h>
#include <dirent.h>

#define IIO_DEVICES_PATH "/sys/bus/iio/devices"
#define MAX_PATH_LEN 256

// Function to find MLX90614 device dynamically
int find_mlx90614_device(char *device_path, size_t path_size) {
    DIR *dir = opendir(IIO_DEVICES_PATH);
    if (!dir) {
        printf("Error: Cannot open %s\n", IIO_DEVICES_PATH);
        return -1;
    }
    
    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        if (strncmp(entry->d_name, "iio:device", 10) == 0) {
            char name_path[MAX_PATH_LEN];
            snprintf(name_path, sizeof(name_path), 
                    "%s/%s/name", IIO_DEVICES_PATH, entry->d_name);
            
            char name[32];
            if (read_file_value(name_path, name, sizeof(name)) == 0) {
                name[strcspn(name, "\n")] = 0;
                if (strcmp(name, "mlx90614") == 0) {
                    snprintf(device_path, path_size, 
                            "%s/%s", IIO_DEVICES_PATH, entry->d_name);
                    closedir(dir);
                    return 0;
                }
            }
        }
    }
    closedir(dir);
    return -1;
}

// Function to read a value from a file (used for IIO device files)
// Returns 0 on success, -1 on error
int read_file_value(const char *filepath, char *buffer, size_t buffer_size) {
    FILE *file = fopen(filepath, "r");
    if (file == NULL) {
        return -1;  // File not found or permission denied
    }
    
    if (fgets(buffer, buffer_size, file) == NULL) {
        fclose(file);
        return -1;  // Failed to read from file
    }
    
    fclose(file);
    return 0;  // Success
}

// Function to read temperature from IIO device
// Reads raw value, scale, and offset from IIO device files and converts to Celsius
// Returns 0 on success, -1 on error
int read_temperature(const char *raw_file, const char *scale_file, const char *offset_file, const char *temp_name, double *temperature) {
    char raw_str[32];
    char scale_str[32];
    char offset_str[32];
    
    // Read raw temperature value from IIO device
    if (read_file_value(raw_file, raw_str, sizeof(raw_str)) != 0) {
        printf("Error: Cannot read %s\n", raw_file);
        return -1;
    }
    
    // Read scale factor (converts raw units to Kelvin)
    if (read_file_value(scale_file, scale_str, sizeof(scale_str)) != 0) {
        printf("Error: Cannot read scale\n");
        return -1;
    }
    
    // Read offset value (Kelvin offset from raw value)
    if (read_file_value(offset_file, offset_str, sizeof(offset_str)) != 0) {
        printf("Error: Cannot read offset\n");
        return -1;
    }
    
    // Convert strings to numbers
    int raw_value = atoi(raw_str);
    double scale = atof(scale_str);
    double offset = atof(offset_str);
    
    // Calculate temperature using IIO standard formula: (raw + offset) * scale / 1000
    // This converts from raw sensor units to Celsius
    *temperature = (raw_value + offset) * scale / 1000.0;
    
    printf("%s Temperature: %.2f°C\n", temp_name, *temperature);
    return 0;
}

int main() {
    char iio_device_path[MAX_PATH_LEN];
    char object_raw_path[MAX_PATH_LEN];
    char ambient_raw_path[MAX_PATH_LEN];
    char scale_path[MAX_PATH_LEN];
    char offset_path[MAX_PATH_LEN];
    double object_temp, ambient_temp;
    
    printf("MLX90614 Temperature Reader (Ctrl+C to exit)\n");
    printf("=============================================\n");
    
    // Find MLX90614 device dynamically
    if (find_mlx90614_device(iio_device_path, sizeof(iio_device_path)) != 0) {
        printf("✗ MLX90614 sensor not found\n");
        printf("Make sure the module is loaded: insmod /oem/usr/ko/mlx90614.ko\n");
        return 1;
    }
    
    printf("✓ MLX90614 sensor found at %s\n", iio_device_path);
    
    // Set up file paths
    snprintf(object_raw_path, sizeof(object_raw_path), "%s/in_temp_object_raw", iio_device_path);
    snprintf(ambient_raw_path, sizeof(ambient_raw_path), "%s/in_temp_ambient_raw", iio_device_path);
    snprintf(scale_path, sizeof(scale_path), "%s/in_temp_scale", iio_device_path);
    snprintf(offset_path, sizeof(offset_path), "%s/in_temp_offset", iio_device_path);
    
    printf("\n");
    
    // Read temperatures continuously
    while (1) {
        // Read object temperature
        if (read_temperature(object_raw_path, scale_path, offset_path, "Object", &object_temp) != 0) {
            printf("Object: Error reading sensor\n");
        }
        
        // Read ambient temperature
        if (read_temperature(ambient_raw_path, scale_path, offset_path, "Ambient", &ambient_temp) != 0) {
            printf("Ambient: Error reading sensor\n");
        }
        
        printf("---\n");
        sleep(2);  // Wait 2 seconds before next reading
    }
    
    return 0;
}[/code]

[b]Updated Makefile[/b]

The Makefile has been updated to compile both C programs:

[code]read_mlx90614-build:
	@rm -rf $(PKG_BIN); \
	mkdir -p $(PKG_BIN)/bin
	# Compile I2C C program
	$(RK_APP_CROSS)-gcc $(READ_MLX90614_CFLAGS) read_mlx90614.c -o $(PKG_BIN)/bin/read_MLX90614 $(READ_MLX90614_LDFLAGS)
	# Compile IIO C program
	$(RK_APP_CROSS)-gcc $(READ_MLX90614_CFLAGS) read_mlx90614_iio.c -o $(PKG_BIN)/bin/read_MLX90614_iio $(READ_MLX90614_LDFLAGS)
	# Copy shell scripts and make them executable
	cp read_mlx90614.sh $(PKG_BIN)/bin/
	chmod +x $(PKG_BIN)/bin/read_mlx90614.sh
	cp read_mlx90614_iio.sh $(PKG_BIN)/bin/
	chmod +x $(PKG_BIN)/bin/read_mlx90614_iio.sh
	# Copy built files to app output directory
	$(call MAROC_COPY_PKG_TO_APP_OUTPUT, $(RK_APP_OUTPUT), $(PKG_BIN))[/code]

[b]Expected Files After Build[/b]

After building and flashing, you should find these files on the target system:

[code]# On the target board (via SSH)
root@luckfox:~# ls /oem/usr/bin/read_*
read_mlx90614      read_mlx90614_iio   read_mlx90614.sh   read_mlx90614_iio.sh[/code]

[b]Sample Output[/b]

[code]# Load the driver first
root@luckfox:~# insmod /oem/usr/ko/mlx90614.ko

# Run the IIO C program
root@luckfox:~# ./read_mlx90614_iio
MLX90614 Temperature Reader (Ctrl+C to exit)
=============================================
✓ MLX90614 sensor found at /sys/bus/iio/devices/iio:device1

Object Temperature: 22.95°C
Ambient Temperature: 22.70°C
---
Object Temperature: 22.97°C
Ambient Temperature: 22.72°C
---
^C[/code]

[size=150]4. Conclusion[/size]

This tutorial has demonstrated two comprehensive approaches for reading data from the MLX90614 temperature sensor on the Luckfox Pico platform:

[b]What We've Covered[/b]

[b]Setup and Configuration[/b]
[list]
[*]Hardware connections and pin assignments
[*]Device tree configuration for I2C2 bus
[*]Enabling i2c-tools and kernel drivers
[*]Building and flashing the complete system
[/list]

[b]Implementation Methods[/b]
[list]
[*][b]Generic I2C Interface:[/b] Direct communication using i2c-tools and custom C programs
[*][b]Kernel Driver with IIO:[/b] Production-ready approach using standardized sensor interfaces
[/list]

[b]Key Features Implemented[/b]
[list]
[*]Dynamic device discovery for robust operation
[*]Multiple implementation options (C programs and shell scripts)
[*]Comprehensive error handling and validation
[*]Real-time temperature monitoring with proper conversion
[/list]

[b]Next Steps[/b]

Now that you have a working MLX90614 sensor interface, you can:

[list]
[*][b]Extend the functionality:[/b] Add data logging, web interfaces, or integration with other sensors
[*][b]Apply the concepts:[/b] Use the I2C and IIO techniques with other sensors
[*][b]Optimize performance:[/b] Implement custom sampling rates or filtering algorithms
[*][b]Integrate with applications:[/b] Connect the sensor data to your main application logic
[/list]

[b]Learning Outcomes[/b]

By completing this tutorial, you've gained practical experience with:
[list]
[*]I2C communication protocols and debugging
[*]Linux kernel driver development and IIO framework
[*]Cross-compilation and embedded Linux development
[*]Device tree configuration and hardware integration
[*]Professional embedded software development practices
[/list]

The techniques and patterns demonstrated here can be applied to integrate virtually any I2C sensor with the Luckfox Pico platform, making this tutorial a valuable foundation for your embedded Linux projects.

[quote]This tutorial provides a comprehensive guide for working with I2C sensors on the Luckfox Pico platform, covering both low-level I2C communication and high-level kernel driver approaches. The examples are production-ready and can be easily adapted for other sensors.[/quote]

:) Happy coding with your MLX90614 sensor! ;)

